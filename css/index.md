## CSS盒子模型？低版本的盒子模型有什么不同？

> + IE盒模型（border-box），`height`和`width`包含`content`、`border`、`padding`。
> + W3C盒模型（content-box），`height`和	`width`只包含`content`，不包含`border`和	`padding`。

## CSS选择符

> + id选择器
> + 类选择器
> + 子代选择器 (`ul > li`)
> + 兄弟选择器	( `li~a`)
> + 相邻兄弟选择器 ( `li + a`)
> + 属性选择器（`a[rel="extenal"]`）

## 元素居中

> + 块级元素使用`margin: 0 auto;`来实现元素水平居中。
> + 利用绝对定位，四个方向的值为0，将`margin`设置为`auto`，可以实现水平和垂直方向的居中。
> + 利用绝对定位，左上角通过`top: 50%`和`left: 50%`定位到页面中心，通过`margin`为负调整。
> + `flex`布局，通过`align-items: center`和`justify-content: center`设置。

## 谈谈Flex布局

> + flex默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。
>
> + `flex-direction` 主轴的方向。          `row`水平方向             `column`垂直方向
>
> + `justify-content` 定义了子项目在主轴上的对齐方式。
>
> + `align-items`定义了子项目在主轴交叉轴的排列方式。
>
>   a
>
> 还可以设置每个项目的属性
>
> + `order` 定义项目的排列顺序，数值越小，越靠前。
> + `flex-grow` 定义项目的放大比例。比如其他项目都为1，如果设置2。为2的空间将是1的一倍。
> + `flex-shrink` 定义项目的缩小比例。数值为0，其他项目为1，则该项目不会缩小。
> + `flex-basic`定义项目在分配空间前，项目占据主轴空间的长度。设置后占据固定空间
> + `align-self` 定义项目在交叉轴的对齐方式
>

## base64编码的优缺点

> 优点：
>
> + 可以减少http请求
>
> 缺点：
>
> + 编码后的文件大小会比原文件大1/3，会增加文件体积。
> + base64无法缓存。
> + 不兼容ie8的浏览器。

## display、position、float之间的关系

> 1. display为`none`时，`position`和`float`不生效
> 2. position为`absolute`或者`fixed`，那么`float`失效，`display`属性变为`block`
> 3. position不为`absolute`或`fixed`，如果`float`生效，`display`属性变为`block`

## position的值relative和absolute定位原点分别是什么？

> 1. `absolute`是绝对定位，相对于第一个不为`static`的父元素进行定位。
> 2. `fixed`是绝对定位的元素，相对于浏览器窗口。
> 3. `relative`生成相对定位的元素，相对于元素本身的位置定位。

## base64图片的优缺点

> 优点：
>
> 1. 减少一个图片的HTTP请求。
>
> 缺点：
>
> 1. 编码转换后的文件体积会变大，会影响文件加载速度。
> 2. 使用base64无法直接缓存。

## BFC规范

> 块格式化上下文（Block Formatting Context）是web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域。
>
> + BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放。
> + 如果一个元素符合触发BFC的条件，则BFC的元素布局不受外部影响。外部的布局也不会影响到内部元素
>
> 创建BFC
>
> 1. 根元素或包含根元素的元素。
> 2. 浮动元素
> 3. 绝对定位元素
> 4. Display = inline-block | flex | inline-flex | table-cell
> 5. Overflow = hidden | auto
>
> 使用：
>
> 1. 清除浮动导致的高度塌陷。
> 2. 解决外边距合并的问题。

## 清除浮动

> 浮动元素不属于文档中的普通流，当元素浮动之后，不会影响块级元素的布局。此时文档中的普通流就会和浮动文件存在不一致的样式。
>
> `清除浮动`是为了清除浮动元素产生的影响。浮动的元素，高度会塌陷，使布局无法正常显示。
>
> **清除浮动的方式**
>
> 1. 使用`clear`属性来清除浮动
> 2. 使用`BFC`特性格式化上下文来清除浮动。

## 媒体查询

> `媒体查询`使指针对不同的媒体类型定义不同的样式。可以针对不同的`屏幕尺寸`设置不同的样式。
>
> ```css
> @media screen and (min-width: 900px){
>   css-code...
> }
> ```

## CSS优化、提高性能的方法

> + 加载性能：
>   1. CSS压缩，压缩文件减少体积。
>   2. 减少使用`@import`，建议使用`link`。后者在页面加载时一起加载，前者等待页面加载完成后加载。
> + 选择器性能
>   1. 选择器的最后面部分为`关键选择器`。CSS选择符是从右到左去进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素。
>   2. 如果使用`ID选择器`，那么则不要增加标签，过滤无关的规则。
>   3. 避免使用`统配选择符`，如 `*{}`
>   4. 尽量避免使用标签选择器，而是使用`class`
> + 渲染性能
>   1. 慎重使用高性能属性：浮动、定位
>   2. 尽量减少页面重排、重绘。
>   3. 去掉空规则
>   4. 属性值为0时，不加单位。
>   5. 属性值为0.**时，可以省略小数点之前的0.
>   6. 选择器减少嵌套

## CSS解析原理

> 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配。

## 设备像素、CSS像素、设备独立像素、dpr、ppi之间的区别？

> + 设备像素指的是物理像素，一般手机的分辨率就是设备像素。
>
> + CSS像素和设备像素是等价的，无论在何种分辨率的设备上，CSS像素大小应该是一致的。
> + DPR指的是设备像素和设备独立像素的比值，一般的PC，DPR = 1；iphone的 DPR = 2；
> + PPI值得是每英寸的物理像素密度。

## 图片格式都有哪些？

> 1. `BMP`是无损的，支持索引色也支持直接色。这种图片格式几乎没有对数据进行压缩，文件较大。
> 2. `GIF`是无损的，文件小支持动画，适合对色彩要求不高并且文件体积较小的场景。
> 3. `JPEG`是有损的，色彩更丰富。文件较大
> 4. `PNG`是无损的，文件体积较小，支持透明度调节。
> 5. `SVG`是无损的，矢量图。由直线和曲线以及绘制它们的方法组成。
> 6. `WEBP`是谷歌开发的一种新的图片格式，图片体积更小。

## 浏览器如何判断是否支持WEBP?

> 1. `宽高判断`：通过创建image对象，将src属性设置为webp格式的图片地址，在onload事件中获取图片的宽高。如果可以获取，那么说明支持。
> 2. `canvas判断`:  类似图片判断，设置canvas的toDataURL为webp格式，判断返回值是否含有`image/webp`字段。

## line-height的特性

> 1. 纯内联元素，可视高度由`line-height`决定。
> 2. 内联元素的高度由固定高度和不固定高度组成。不固定的部分就是`line-height`。
> 3. 块级元素的`line-height`对本身没有作用，优先以`height`为准。

## overflow的特性

> 1. 设置了`overflow:hidden`的元素，同时存在`border`和`padding`属性时，当子元素内容超出父容器时，剪裁的边界是border-box的边缘。
> 2. 滚动条会占用容器的宽度和高度。
> 3. 元素设置了该属性时，内容溢出滚动依然存在，仅仅是滚动条不展示
